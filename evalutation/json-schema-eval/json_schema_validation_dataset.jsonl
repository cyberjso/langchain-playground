{"inputs": {"code": "package main\nimport (\n  \"net/http\"\n  \"io/ioutil\"\n)\n\nfunc fetch(url string) string {\n  resp, _ := http.Get(url)\n  body, _ := ioutil.ReadAll(resp.Body)\n  defer resp.Body.Close()\n  return string(body)\n}"}, "outputs": {"findings": [{"type": "missing_timeout", "line": 8, "description": "http.Get sem contexto ou timeout pode travar indefinidamente", "severity": "medium"}, {"type": "ignored_error", "line": 8, "description": "erro de http.Get ignorado", "severity": "high"}, {"type": "ignored_error", "line": 9, "description": "erro de ReadAll ignorado", "severity": "medium"}, {"type": "missing_status_check", "line": 9, "description": "não verifica status code antes de ler o corpo", "severity": "low"}], "summary": "Adicionar timeout via contexto, checar erros de http.Get e io.ReadAll e validar status code antes de ler o corpo."}, "metadata": {"topic": "http_client", "category": "robustness"}}
{"inputs": {"code": "package repo\n\nimport (\n  \"database/sql\"\n  \"fmt\"\n)\n\nfunc GetUser(db *sql.DB, username string) (int, error) {\n  query := fmt.Sprintf(\"SELECT id FROM users WHERE username = '%s'\", username)\n  row := db.QueryRow(query)\n  var id int\n  if err := row.Scan(&id); err != nil {\n    return 0, err\n  }\n  return id, nil\n}"}, "outputs": {"findings": [{"type": "sql_injection", "line": 10, "description": "query concatenada com input do usuário permite SQL injection, use parâmetros", "severity": "critical"}, {"type": "missing_timeout", "line": 11, "description": "QueryRow sem contexto com timeout", "severity": "medium"}], "summary": "Use parâmetros preparados em vez de Sprintf e rode a consulta com contexto e timeout."}, "metadata": {"topic": "database", "category": "security"}}
{"inputs": {"code": "package main\n\nimport \"database/sql\"\n\nfunc GetAllUsers(db *sql.DB) []User {\n  users := []User{}\n  ids := []int{1, 2, 3, 4, 5}\n  for _, id := range ids {\n    row := db.QueryRow(\"SELECT * FROM users WHERE id = ?\", id)\n    var u User\n    row.Scan(&u.ID, &u.Name)\n    users = append(users, u)\n  }\n  return users\n}"}, "outputs": {"findings": [{"type": "n_plus_1_query", "line": 9, "description": "Loop executa query individual por ID - deveria usar WHERE IN ou JOIN", "severity": "high"}, {"type": "missing_index", "line": 9, "description": "Se não houver índice em 'id', cada query será lenta", "severity": "medium"}, {"type": "ignored_error", "line": 10, "description": "Erro de Scan ignorado pode corromper dados", "severity": "medium"}], "summary": "Usar query única com WHERE IN ao invés de loop com queries individuais (N+1 problem)."}, "metadata": {"topic": "database", "category": "performance"}}
{"inputs": {"code": "package api\n\nimport (\n  \"context\"\n  \"time\"\n)\n\nfunc ProcessBatch(ctx context.Context, items []string) {\n  for _, item := range items {\n    time.Sleep(5 * time.Second)\n    result := heavyComputation(item)\n    saveToDatabase(result)\n  }\n}"}, "outputs": {"findings": [{"type": "blocking_operation", "line": 10, "description": "Sleep bloqueante - deveria processar em goroutines paralelas", "severity": "high"}, {"type": "no_context_check", "line": 10, "description": "Não verifica ctx.Done() - pode continuar processando após timeout", "severity": "medium"}, {"type": "sequential_processing", "line": 9, "description": "Processamento sequencial quando poderia ser paralelo", "severity": "high"}], "summary": "Usar worker pool com goroutines para processamento paralelo e respeitar context cancellation."}, "metadata": {"topic": "concurrency", "category": "performance"}}
{"inputs": {"code": "package main\n\nfunc calculate(a int, b int, c int, d int, e int, f int, g int) int {\n  var result int\n  result = a + b\n  result = result + c\n  result = result + d\n  result = result + e\n  result = result + f\n  result = result + g\n  if result > 100 {\n    result = result - 50\n  }\n  if result < 0 {\n    result = 0\n  }\n  return result\n}"}, "outputs": {"findings": [{"type": "too_many_parameters", "line": 3, "description": "Função com 7 parâmetros - difícil de usar e manter, use struct", "severity": "medium"}, {"type": "poor_naming", "line": 3, "description": "Nomes de variáveis genéricos (a, b, c) - sem significado", "severity": "medium"}, {"type": "code_duplication", "line": 5, "description": "Múltiplas linhas fazendo 'result = result + x' - poderia usar loop ou sum", "severity": "low"}], "summary": "Refatorar para aceitar slice ou struct com campos bem nomeados, usar loop para soma."}, "metadata": {"topic": "code_quality", "category": "maintainability"}}
{"inputs": {"code": "package utils\n\nfunc ProcessData(data string) string {\n  data = cleanData(data)\n  data = validateData(data)\n  data = transformData(data)\n  data = enrichData(data)\n  data = formatData(data)\n  return data\n}\n\nfunc cleanData(d string) string { return d }\nfunc validateData(d string) string { return d }\nfunc transformData(d string) string { return d }\nfunc enrichData(d string) string { return d }\nfunc formatData(d string) string { return d }"}, "outputs": {"findings": [{"type": "missing_error_handling", "line": 4, "description": "Nenhuma função retorna erro - validação deveria poder falhar", "severity": "high"}, {"type": "unclear_flow", "line": 3, "description": "Pipeline de transformações sem indicação clara de propósito", "severity": "medium"}, {"type": "stub_functions", "line": 13, "description": "Funções stub vazias - implementação incompleta", "severity": "high"}], "summary": "Adicionar tratamento de erros em cada etapa e implementar lógica real das funções."}, "metadata": {"topic": "code_quality", "category": "maintainability"}}
{"inputs": {"code": "package main\n\nimport \"os/exec\"\n\nfunc RunCommand(userInput string) string {\n  cmd := exec.Command(\"sh\", \"-c\", userInput)\n  output, _ := cmd.Output()\n  return string(output)\n}"}, "outputs": {"findings": [{"type": "command_injection", "line": 6, "description": "Executar comando shell com input não sanitizado permite command injection", "severity": "critical"}, {"type": "ignored_error", "line": 7, "description": "Erro de cmd.Output() ignorado pode esconder falhas", "severity": "medium"}], "summary": "NUNCA executar comandos shell com input do usuário. Se necessário, use whitelist de comandos permitidos."}, "metadata": {"topic": "command_execution", "category": "security"}}
{"inputs": {"code": "package main\n\nimport (\n  \"net/http\"\n  \"fmt\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n  name := r.URL.Query().Get(\"name\")\n  fmt.Fprintf(w, \"<h1>Hello %s</h1>\", name)\n}"}, "outputs": {"findings": [{"type": "xss_vulnerability", "line": 10, "description": "Output não escapado permite XSS - use html/template", "severity": "critical"}, {"type": "missing_input_validation", "line": 9, "description": "Input não validado pode conter conteúdo malicioso", "severity": "high"}], "summary": "Usar html/template para escapar output automaticamente e validar input do usuário."}, "metadata": {"topic": "web", "category": "security"}}
{"inputs": {"code": "package cache\n\nimport \"sync\"\n\ntype Cache struct {\n  data map[string][]byte\n  mu   sync.Mutex\n}\n\nfunc (c *Cache) Get(key string) []byte {\n  c.mu.Lock()\n  defer c.mu.Unlock()\n  return c.data[key]\n}\n\nfunc (c *Cache) Set(key string, value []byte) {\n  c.mu.Lock()\n  c.data[key] = value\n  c.mu.Unlock()\n}"}, "outputs": {"findings": [{"type": "inefficient_locking", "line": 11, "description": "Mutex para leitura - deveria usar sync.RWMutex para permitir leituras concorrentes", "severity": "high"}, {"type": "unbounded_growth", "line": 18, "description": "Map cresce indefinidamente - sem TTL ou eviction policy", "severity": "medium"}, {"type": "missing_defer", "line": 18, "description": "Set não usa defer unlock - se panic acontecer, deadlock", "severity": "high"}], "summary": "Usar RWMutex, adicionar defer em Set e implementar cache eviction policy."}, "metadata": {"topic": "concurrency", "category": "performance"}}
{"inputs": {"code": "package main\n\nfunc CalculateTotal(items []Item) float64 {\n  var total float64\n  for i := 0; i < len(items); i++ {\n    total = total + items[i].Price\n    total = total + items[i].Tax\n    total = total - items[i].Discount\n  }\n  if total < 0 {\n    total = 0\n  }\n  return total\n}"}, "outputs": {"findings": [{"type": "verbose_loop", "line": 5, "description": "Loop tradicional ao invés de range - menos idiomático em Go", "severity": "low"}, {"type": "code_duplication", "line": 6, "description": "Múltiplas atribuições 'total = total + x' - poderia usar operador +=", "severity": "low"}, {"type": "magic_logic", "line": 10, "description": "Lógica de 'total negativo vira 0' sem explicação - adicionar comentário", "severity": "medium"}], "summary": "Usar range loop, operador += e adicionar comentário explicando regra de negócio."}, "metadata": {"topic": "code_quality", "category": "maintainability"}}
{"inputs": {"code": "package main\n\nfunc Add(a, b int) int {\n  return a + b\n}"}, "outputs": {"findings": [], "summary": "Função simples sem problemas aparentes"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Multiply(x, y int) int {\n  return x * y\n}"}, "outputs": {"findings": [], "summary": "Função de multiplicação correta"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Subtract(a, b int) int {\n  return a - b\n}"}, "outputs": {"findings": [], "summary": "Subtração implementada corretamente"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Divide(a, b int) int {\n  return a / b\n}"}, "outputs": {"findings": [{"type": "division_by_zero", "line": 4, "description": "Não verifica divisão por zero", "severity": "high"}], "summary": "Adicionar verificação de divisão por zero"}, "metadata": {"topic": "division_by_zero", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Simple() {\n  fmt.Println(\"hello\")\n}"}, "outputs": {"findings": [{"type": "import_missing", "line": 4, "description": "Falta importar pacote fmt", "severity": "high"}], "summary": "Adicionar import do pacote fmt"}, "metadata": {"topic": "import_missing", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Hello() string {\n  return \"world\"\n}"}, "outputs": {"findings": [], "summary": "Função simples que retorna string"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nimport \"fmt\"\n\nfunc Print() {\n  fmt.Println(\"test\")\n}"}, "outputs": {"findings": [], "summary": "Função de print básica"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Max(a, b int) int {\n  if a > b {\n    return a\n  }\n  return b\n}"}, "outputs": {"findings": [], "summary": "Função max implementada corretamente"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Min(a, b int) int {\n  if a < b {\n    return a\n  }\n  return b\n}"}, "outputs": {"findings": [], "summary": "Função min implementada corretamente"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Factorial(n int) int {\n  if n == 0 {\n    return 1\n  }\n  return n * Factorial(n-1)\n}"}, "outputs": {"findings": [{"type": "stack_overflow", "line": 6, "description": "Recursão sem limite pode causar stack overflow para valores grandes", "severity": "high"}], "summary": "Adicionar verificação para evitar recursão excessiva"}, "metadata": {"topic": "recursion", "category": "performance"}}
{"inputs": {"code": "package main\n\nimport \"os\"\n\nfunc ReadFile(filename string) string {\n  data, err := os.ReadFile(filename)\n  if err != nil {\n    return \"\"\n  }\n  return string(data)\n}"}, "outputs": {"findings": [{"type": "error_swallowing", "line": 7, "description": "Erro de leitura de arquivo ignorado, deveria ser retornado ou logado", "severity": "medium"}], "summary": "Tratar erro de leitura de arquivo de forma adequada"}, "metadata": {"topic": "file_handling", "category": "robustness"}}
{"inputs": {"code": "package main\n\nfunc Fibonacci(n int) int {\n  if n <= 1 {\n    return n\n  }\n  return Fibonacci(n-1) + Fibonacci(n-2)\n}"}, "outputs": {"findings": [{"type": "inefficient_algorithm", "line": 6, "description": "Cálculo recursivo de Fibonacci é ineficiente, use memoization", "severity": "high"}], "summary": "Implementar memoization para melhorar eficiência"}, "metadata": {"topic": "algorithm", "category": "performance"}}
{"inputs": {"code": "package main\n\nimport \"fmt\"\n\nfunc Greet(name string) {\n  fmt.Printf(\"Hello, %s!\\n\", name)\n}"}, "outputs": {"findings": [], "summary": "Função de saudação simples e funcional"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Sum(numbers []int) int {\n  total := 0\n  for _, num := range numbers {\n    total += num\n  }\n  return total\n}"}, "outputs": {"findings": [], "summary": "Função de soma implementada corretamente"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nimport \"os\"\n\nfunc DeleteFile(filename string) error {\n  return os.Remove(filename)\n}"}, "outputs": {"findings": [{"type": "missing_error_handling", "line": 5, "description": "Erro de remoção de arquivo não tratado", "severity": "medium"}], "summary": "Tratar erro ao remover arquivo"}, "metadata": {"topic": "file_handling", "category": "robustness"}}
{"inputs": {"code": "package main\n\nfunc ReverseString(s string) string {\n  runes := []rune(s)\n  for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n    runes[i], runes[j] = runes[j], runes[i]\n  }\n  return string(runes)\n}"}, "outputs": {"findings": [], "summary": "Função de reversão de string implementada corretamente"}, "metadata": {"topic": "string_manipulation", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc IsEven(n int) bool {\n  return n%2 == 0\n}"}, "outputs": {"findings": [], "summary": "Função para verificar se número é par implementada corretamente"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Power(base, exponent int) int {\n  result := 1\n  for i := 0; i < exponent; i++ {\n    result *= base\n  }\n  return result\n}"}, "outputs": {"findings": [], "summary": "Função de cálculo de potência implementada corretamente"}, "metadata": {"topic": "simple_function", "category": "testing"}}


{"inputs": {"code": "package main\n\nfunc Square(n int) int {\n  return n * n\n}"}, "outputs": {"findings": [], "summary": "Função de cálculo de quadrado implementada corretamente"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Cube(n int) int {\n  return n * n * n\n}"}, "outputs": {"findings": [], "summary": "Função de cálculo de cubo implementada corretamente"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Abs(n int) int {\n  if n < 0 {\n    return -n\n  }\n  return n\n}"}, "outputs": {"findings": [], "summary": "Função de cálculo de valor absoluto implementada corretamente"}, "metadata": {"topic": "simple_function", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc IsPrime(n int) bool {\n  if n <= 1 {\n    return false\n  }\n  for i := 2; i*i <= n; i++ {\n    if n%i == 0 {\n      return false\n    }\n  }\n  return true\n}"}, "outputs": {"findings": [], "summary": "Função para verificar se número é primo implementada corretamente"}, "metadata": {"topic": "algorithm", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc GCD(a, b int) int {\n  for b != 0 {\n    a, b = b, a%b\n  }\n  return a\n}"}, "outputs": {"findings": [], "summary": "Função de cálculo do MDC implementada corretamente"}, "metadata": {"topic": "algorithm", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc LCM(a, b int) int {\n  return a / GCD(a, b) * b\n}"}, "outputs": {"findings": [], "summary": "Função de cálculo do MMC implementada corretamente"}, "metadata": {"topic": "algorithm", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc FactorialIterative(n int) int {\n  result := 1\n  for i := 2; i <= n; i++ {\n    result *= i\n  }\n  return result\n}"}, "outputs": {"findings": [], "summary": "Função de cálculo de fatorial iterativo implementada corretamente"}, "metadata": {"topic": "algorithm", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Average(numbers []float64) float64 {\n  total := 0.0\n  for _, num := range numbers {\n    total += num\n  }\n  return total / float64(len(numbers))\n}"}, "outputs": {"findings": [], "summary": "Função de cálculo de média implementada corretamente"}, "metadata": {"topic": "math", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Median(numbers []int) float64 {\n  sort.Ints(numbers)\n  n := len(numbers)\n  if n%2 == 0 {\n    return float64(numbers[n/2-1]+numbers[n/2]) / 2.0\n  }\n  return float64(numbers[n/2])\n}"}, "outputs": {"findings": [{"type": "import_missing", "line": 4, "description": "Falta importar pacote sort", "severity": "high"}], "summary": "Adicionar import do pacote sort"}, "metadata": {"topic": "math", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Mode(numbers []int) int {\n  freq := make(map[int]int)\n  maxFreq := 0\n  mode := 0\n  for _, num := range numbers {\n    freq[num]++\n    if freq[num] > maxFreq {\n      maxFreq = freq[num]\n      mode = num\n    }\n  }\n  return mode\n}"}, "outputs": {"findings": [], "summary": "Função de cálculo da moda implementada corretamente"}, "metadata": {"topic": "math", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Contains(slice []int, value int) bool {\n  for _, v := range slice {\n    if v == value {\n      return true\n    }\n  }\n  return false\n}"}, "outputs": {"findings": [], "summary": "Função para verificar se slice contém valor implementada corretamente"}, "metadata": {"topic": "slice_operations", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc RemoveDuplicates(slice []int) []int {\n  seen := make(map[int]bool)\n  result := []int{}\n  for _, v := range slice {\n    if !seen[v] {\n      seen[v] = true\n      result = append(result, v)\n    }\n  }\n  return result\n}"}, "outputs": {"findings": [], "summary": "Função para remover duplicatas de slice implementada corretamente"}, "metadata": {"topic": "slice_operations", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc ReverseSlice(slice []int) []int {\n  for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {\n    slice[i], slice[j] = slice[j], slice[i]\n  }\n  return slice\n}"}, "outputs": {"findings": [], "summary": "Função para reverter slice implementada corretamente"}, "metadata": {"topic": "slice_operations", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc MergeSlices(a, b []int) []int {\n  return append(a, b...)\n}"}, "outputs": {"findings": [], "summary": "Função para mesclar slices implementada corretamente"}, "metadata": {"topic": "slice_operations", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc MapSlice(slice []int, f func(int) int) []int {\n  result := make([]int, len(slice))\n  for i, v := range slice {\n    result[i] = f(v)\n  }\n  return result\n}"}, "outputs": {"findings": [], "summary": "Função para mapear slice implementada corretamente"}, "metadata": {"topic": "slice_operations", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc FilterSlice(slice []int, f func(int) bool) []int {\n  result := []int{}\n  for _, v := range slice {\n    if f(v) {\n      result = append(result, v)\n    }\n  }\n  return result\n}"}, "outputs": {"findings": [], "summary": "Função para filtrar slice implementada corretamente"}, "metadata": {"topic": "slice_operations", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc ReduceSlice(slice []int, f func(int, int) int, initial int) int {\n  result := initial\n  for _, v := range slice {\n    result = f(result, v)\n  }\n  return result\n}"}, "outputs": {"findings": [], "summary": "Função para reduzir slice implementada corretamente"}, "metadata": {"topic": "slice_operations", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc CountOccurrences(slice []int, value int) int {\n  count := 0\n  for _, v := range slice {\n    if v == value {\n      count++\n    }\n  }\n  return count\n}"}, "outputs": {"findings": [], "summary": "Função para contar ocorrências em slice implementada corretamente"}, "metadata": {"topic": "slice_operations", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc FindMax(slice []int) int {\n  max := slice[0]\n  for _, v := range slice {\n    if v > max {\n      max = v\n    }\n  }\n  return max\n}"}, "outputs": {"findings": [], "summary": "Função para encontrar o maior valor em slice implementada corretamente"}, "metadata": {"topic": "slice_operations", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc FindMin(slice []int) int {\n  min := slice[0]\n  for _, v := range slice {\n    if v < min {\n      min = v\n    }\n  }\n  return min\n}"}, "outputs": {"findings": [], "summary": "Função para encontrar o menor valor em slice implementada corretamente"}, "metadata": {"topic": "slice_operations", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc BinarySearch(slice []int, target int) int {\n  left, right := 0, len(slice)-1\n  for left <= right {\n    mid := (left + right) / 2\n    if slice[mid] == target {\n      return mid\n    } else if slice[mid] < target {\n      left = mid + 1\n    } else {\n      right = mid - 1\n    }\n  }\n  return -1\n}"}, "outputs": {"findings": [{"type": "precondition_missing", "line": 4, "description": "Binary search requer slice ordenado, mas não é verificado", "severity": "medium"}], "summary": "Adicionar verificação para garantir que slice está ordenado"}, "metadata": {"topic": "algorithm", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc QuickSort(slice []int) []int {\n  if len(slice) < 2 {\n    return slice\n  }\n  pivot := slice[0]\n  less := []int{}\n  greater := []int{}\n  for _, v := range slice[1:] {\n    if v <= pivot {\n      less = append(less, v)\n    } else {\n      greater = append(greater, v)\n    }\n  }\n  return append(append(QuickSort(less), pivot), QuickSort(greater)...)\n}"}, "outputs": {"findings": [], "summary": "Função de QuickSort implementada corretamente"}, "metadata": {"topic": "algorithm", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc BubbleSort(slice []int) []int {\n  n := len(slice)\n  for i := 0; i < n; i++ {\n    for j := 0; j < n-i-1; j++ {\n      if slice[j] > slice[j+1] {\n        slice[j], slice[j+1] = slice[j+1], slice[j]\n      }\n    }\n  }\n  return slice\n}"}, "outputs": {"findings": [], "summary": "Função de BubbleSort implementada corretamente"}, "metadata": {"topic": "algorithm", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc MergeSort(slice []int) []int {\n  if len(slice) < 2 {\n    return slice\n  }\n  mid := len(slice) / 2\n  left := MergeSort(slice[:mid])\n  right := MergeSort(slice[mid:])\n  return merge(left, right)\n}\n\nfunc merge(left, right []int) []int {\n  result := []int{}\n  i, j := 0, 0\n  for i < len(left) && j < len(right) {\n    if left[i] < right[j] {\n      result = append(result, left[i])\n      i++\n    } else {\n      result = append(result, right[j])\n      j++\n    }\n  }\n  result = append(result, left[i:]...)\n  result = append(result, right[j:]...)\n  return result\n}"}, "outputs": {"findings": [], "summary": "Função de MergeSort implementada corretamente"}, "metadata": {"topic": "algorithm", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc InsertionSort(slice []int) []int {\n  for i := 1; i < len(slice); i++ {\n    key := slice[i]\n    j := i - 1\n    for j >= 0 && slice[j] > key {\n      slice[j+1] = slice[j]\n      j--\n    }\n    slice[j+1] = key\n  }\n  return slice\n}"}, "outputs": {"findings": [], "summary": "Função de InsertionSort implementada corretamente"}, "metadata": {"topic": "algorithm", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc SelectionSort(slice []int) []int {\n  n := len(slice)\n  for i := 0; i < n; i++ {\n    minIdx := i\n    for j := i + 1; j < n; j++ {\n      if slice[j] < slice[minIdx] {\n        minIdx = j\n      }\n    }\n    slice[i], slice[minIdx] = slice[minIdx], slice[i]\n  }\n  return slice\n}"}, "outputs": {"findings": [], "summary": "Função de SelectionSort implementada corretamente"}, "metadata": {"topic": "algorithm", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc CountSort(slice []int, maxVal int) []int {\n  count := make([]int, maxVal+1)\n  for _, v := range slice {\n    count[v]++\n  }\n  result := []int{}\n  for i, c := range count {\n    for c > 0 {\n      result = append(result, i)\n      c--\n    }\n  }\n  return result\n}"}, "outputs": {"findings": [], "summary": "Função de CountSort implementada corretamente"}, "metadata": {"topic": "algorithm", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc IsPalindrome(s string) bool {\n  for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\n    if s[i] != s[j] {\n      return false\n    }\n  }\n  return true\n}"}, "outputs": {"findings": [], "summary": "Função para verificar se string é palíndromo implementada corretamente"}, "metadata": {"topic": "string_manipulation", "category": "testing"}}
{"inputs": {"code": "package main\n\nfunc Anagram(s1, s2 string) bool {\n  if len(s1) != len(s2) {\n    return false\n  }\n  count := make(map[rune]int)\n  for _, r := range s1 {\n    count[r]++\n  }\n  for _, r := range s2 {\n    count[r]--\n    if count[r] < 0 {\n      return false\n    }\n  }\n  return true\n}"}, "outputs": {"findings": [], "summary": "Função para verificar se duas strings são anagramas implementada corretamente"}, "metadata": {"topic": "string_manipulation", "category": "testing"}}